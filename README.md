# -BIG-C-SEUNGBEOMSEO-
1. 정규 표현식(Regular Expression)
정규 표현식(Regular Expression)은 문자열을 처리하고 패턴을 검색, 추출 또는 대체하기 위한 강력한 도구입니다.
파이썬에서 정규 표현식을 사용하기 위해 re 모듈을 import해야 합니다. re 모듈은 정규 표현식을 작성하고 패턴을 처리하는 함수와 메서드를 제공합니다.
import re

# 정규 표현식 패턴
pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}\b'

# 대상 문자열
text = "이것은 텍스트 예시입니다. abc123@example.com과 def456@example.com은 이메일 주소입니다."

# 패턴 검색
matches = re.findall(pattern, text)

# 결과 출력
for match in matches:
    print(match)
위의 코드에서는 다음과 같은 작업을 수행합니다:
1. re 모듈을 import합니다.
2. 정규 표현식 패턴을 pattern 변수에 할당합니다. 이 패턴은 이메일 주소를 검색하기 위한 패턴입니다.
3. 대상 문자열을 text 변수에 할당합니다.
4. re.findall() 함수를 사용하여 패턴과 일치하는 모든 문자열을 찾습니다. 이 함수는 리스트 형태로 일치하는 문자열들을 반환합니다.
5. for 루프를 통해 찾은 이메일 주소를 하나씩 출력합니다.
출력 결과는 다음과 같이 나올 것입니다:
abc123@example.com
def456@example.com
이 예제에서는 정규 표현식을 사용하여 이메일 주소를 추출했지만, 정규 표현식은 더 복잡한 패턴을 처리할 수 있습니다. 각각의 정규 표현식 패턴은 특정한 규칙을 따르며, 이를 이용하여 문자열을 유연하게 처리할 수 있습니다.

2. 가비지 컬렉션(Garbage Collection)
가비지 컬렉션(Garbage collection)은 프로그래밍 언어 런타임 환경에서 자동으로 동적으로 할당된 메모리 중에서 더 이상 사용되지 않는 객체를 식별하고 제거하는 기능입니다. 가비지 컬렉션은 메모리 관리를 단순화하고 프로그래머가 명시적으로 메모리를 해제하지 않아도 되는 장점을 제공합니다.
가비지 컬렉션의 동작 메커니즘은 언어와 런타임 환경에 따라 다를 수 있지만, 대부분의 가비지 컬렉션 시스템은 다음과 같은 기본 원리를 따릅니다:
Reachability: 가비지 컬렉션은 메모리 상에서 어떤 객체가 더 이상 접근할 수 없는 상태인지 판단합니다. 일반적으로 "루트(root)"라고 불리는 객체 집합을 기준으로 시작하여, 루트에서 직간접적으로 참조 가능한 객체들을 순회하며 접근 가능한 상태인지 확인합니다.
Marking: 접근 가능한 객체들은 표시(mark)되어 메모리 내부에 마킹됩니다. 이 단계에서는 가비지 컬렉터가 객체에 대한 메타데이터를 유지하고 필요한 경우 추가적인 데이터 구조를 사용하여 마킹합니다.
Sweep and Free: 마킹되지 않은 객체들은 더 이상 사용되지 않는 것으로 간주되고, 해당 객체들이 사용한 메모리를 해제합니다. 이 단계에서는 가비지 컬렉터가 마킹되지 않은 객체들을 식별하고, 해당 객체들의 메모리를 운영체제에 반환합니다.
가비지 컬렉션이 제대로 동작하기 위해서는 다음의 지침을 따라 코드를 작성해야 합니다:
참조 관리: 객체를 더 이상 사용하지 않을 때, 해당 객체에 대한 모든 참조를 명시적으로 제거해야 합니다. 예를 들어, 객체가 어떤 컬렉션에서 제거되었다면, 해당 컬렉션에서의 참조를 해제해야 합니다.
긴 생명 주기 객체 관리: 객체의 생명 주기가 길다면, 해당 객체에 대한 참조를 최대한 제한하여 가비지 컬렉션이 해당 객체를 더 빨리 식별하고 메모리를 해제할 수 있도록 해야 합니다. 객체의 사용이 끝난 후에는 객체에 대한 참조를 해제하는 것이 중요합니다.
순환 참조 방지: 두 개 이상
가비지 컬렉션(GC)로도 메모리 누수(memory leak)가 발생할 수 있습니다. 메모리 누수는 가비지 컬렉터가 객체를 정리하지 못하고 계속해서 메모리를 점유하는 상황을 말합니다. 가비지 컬렉션을 사용하는 언어 중에서도, 몇 가지 일반적인 메모리 누수의 예시를 살펴보겠습니다.
예시 1: 순환 참조에 의한 메모리 누수
class Node {
  Node next;
}

void createCircularReference() {
  Node nodeA = new Node();
  Node nodeB = new Node();

  nodeA.next = nodeB;
  nodeB.next = nodeA;
}

이 예제에서는 Node 객체 두 개를 생성하고, 서로를 참조하는 순환 참조(circular reference)를 만듭니다. 이 경우, 가비지 컬렉터는 이 두 객체를 정리하지 못하고 메모리에 계속 남게 됩니다. 두 객체는 서로를 참조하고 있으므로 접근 가능한 상태이지만, 프로그램의 어느 부분에서도 접근할 수 없습니다. 이런 순환 참조가 계속 존재하면, 메모리 누수가 발생합니다. 이 문제를 해결하기 위해서는 참조를 명시적으로 끊어주어야 합니다.
예시 2: 정적 컬렉션에 대한 잘못된 사용
class MyClass {
  private static List<String> myList = new ArrayList<>();

  public void addToMyList(String item) {
    myList.add(item);
  }
}
이 예제에서는 MyClass 내부에 정적(static)으로 myList라는 List 객체를 생성하고, addToMyList 메서드를 통해 myList에 항목을 추가합니다. 그러나 myList는 정적으로 선언되었으므로 MyClass의 인스턴스 수에 관계없이 메모리에 계속해서 유지됩니다. 따라서 MyClass의 인스턴스가 소멸해도 myList는 계속해서 메모리를 점유하게 되는데, 이는 가비지 컬렉션에서 제대로 정리되지 않는 메모리 누수로 이어집니다. 이 문제를 해결하기 위해서는 정적 컬렉션에 저장된 항목을 필요 없을 때 적절하게 제거해주어야 합니다.
이처럼 가비지 컬렉션으로도 메모리 누수가 발생할 수 있지만, 메모리 누수를 최소화하기 위해서는 명시적인 메모리 관리와 참조 해제를 신경써야 합니다.
